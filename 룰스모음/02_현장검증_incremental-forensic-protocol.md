# Incremental Forensic Analysis Protocol (계단식 포렌식 분석 프로토콜)

**버전**: 1.0
**생성일**: 2025-12-11
**목적**: AI 에이전트의 맥락 창 한계를 파일 시스템으로 우회하고, 계단식 순차 분석으로 완전한 현장 분석을 수행하는 프로토콜

---

## 1. 개요

### 1.1 프로토콜 정의

이 프로토콜은 **파일 시스템을 AI의 외부 기억장치로 활용**하여 맥락 창 한계를 우회하고, **계단식(Incremental) 순차 분석**으로 완전하고 검증 가능한 현장 분석을 수행합니다.

```
╔═════════════════════════════════════════════════════════════════════════════════╗
║                        핵심 혁신: AI의 장점을 극대화                             ║
╠═════════════════════════════════════════════════════════════════════════════════╣
║                                                                                  ║
║  1. 🧠 파일 = AI의 외부 기억                                                    ║
║     - 맥락 창에서 사라져도 파일에 남아있음                                      ║
║     - 다음 단계에서 이전 파일 읽기로 맥락 복원                                  ║
║                                                                                  ║
║  2. 🪜 계단식 분석                                                               ║
║     - 한 번에 하나의 단계만                                                      ║
║     - 각 단계 결과를 파일로 저장                                                 ║
║     - 다음 단계는 이전 파일을 읽고 시작                                          ║
║                                                                                  ║
║  3. ⏰ AI는 지치지 않는다                                                        ║
║     - 철저한 기록, 순차 분석, 다양한 관점                                        ║
║     - 검증하고, 통합하고, 다시 검증                                              ║
║                                                                                  ║
║  4. ✅ 상태 머신 기반 실행                                                       ║
║     - 현재 Phase를 파일에 기록                                                   ║
║     - AI가 파일을 읽으면 다음 할 일을 안다                                       ║
║                                                                                  ║
║  5. 🔄 자동 검증 시스템                                                          ║
║     - 존재 검증: 파일/코드가 실제로 있는가?                                      ║
║     - 일관성 검증: 파일 간 내용이 일치하는가?                                    ║
║     - 증거 검증: 결론에 코드 인용이 있는가?                                      ║
║     - 커버리지 검증: 미분석 파일 비율은?                                         ║
║                                                                                  ║
╚═════════════════════════════════════════════════════════════════════════════════╝
```

### 1.2 학술적 배경

| 이론/연구 | 출처 | 적용 |
|-----------|------|------|
| **External Memory Systems** | Clark & Chalmers (1998) | 파일 시스템 = 확장된 인지 |
| **Incremental Processing** | Demers et al. (1981) | 계단식 순차 처리 |
| **State Machine Execution** | Finite State Machines | 상태 기반 진행 제어 |
| **Software Forensics** | Spafford & Weeber (1993) | 증거 기반 분석 |
| **Systematic Code Review** | Fagan (1976) | 체계적 검토 프로세스 |
| **Evidence-Based Practice** | Sackett (1996) | 증거 기반 의사결정 |

### 1.3 AI 에이전트 특성 분석

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│  AI 에이전트 특성 → 프로토콜 설계                                                │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  ✅ 장점 → 극대화                                                               │
│  ┌─────────────────────────────────────────────────────────────────────────┐    │
│  │  1. 지치지 않는다 → 철저한 순차 분석 요구 가능                          │    │
│  │  2. 기록을 잘한다 → 모든 단계를 파일로 기록                             │    │
│  │  3. 규칙을 따른다 → 상태 머신으로 다음 단계 안내                        │    │
│  │  4. 검증 가능하다 → grep/read_file로 모든 주장 확인                     │    │
│  │  5. 다양한 관점 가능 → 여러 팀 페르소나로 분석                          │    │
│  └─────────────────────────────────────────────────────────────────────────┘    │
│                                                                                  │
│  ❌ 단점 → 파일 시스템으로 극복                                                 │
│  ┌─────────────────────────────────────────────────────────────────────────┐    │
│  │  1. 맥락 창 제한 → 파일에 저장하면 사라지지 않음                        │    │
│  │  2. 환각 경향 → 자동 검증으로 거짓말 탐지                               │    │
│  │  3. 선택적 편향 → 커버리지 추적으로 누락 탐지                           │    │
│  │  4. 상태 기억 못함 → 상태 머신 파일로 현재 위치 기억                    │    │
│  │  5. 이전 단계 망각 → 이전 파일 읽기로 복원                              │    │
│  └─────────────────────────────────────────────────────────────────────────┘    │
│                                                                                  │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### 1.4 기존 프레임워크와의 관계

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                        프레임워크 통합 아키텍처                                   │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  ┌─────────────────────────────────────────────────────────────────────────┐    │
│  │  04_계단식분석 (이 프로토콜) - 실행 엔진                                 │    │
│  │  • 파일 기반 상태 관리                                                  │    │
│  │  • 계단식 순차 분석                                                      │    │
│  │  • 자동 검증 시스템                                                      │    │
│  └─────────────────────────────────────────────────────────────────────────┘    │
│                              ↓ 통합                                              │
│  ┌───────────────────────────────────────────────────────────────────────┐      │
│  │  01_분석 (Adversarial Framework)         03_현장분석 (Forensic)        │      │
│  │  • VETO 시스템                           • 8개 분석 팀                  │      │
│  │  • 가중 투표                             • 줌 레벨 전환                 │      │
│  │  • 소수 의견 보호                        • 커버리지 추적                │      │
│  └───────────────────────────────────────────────────────────────────────┘      │
│                              ↓ 통합                                              │
│  ┌─────────────────────────────────────────────────────────────────────────┐    │
│  │  02_검증 (Verification Strike Force)                                    │    │
│  │  • 6개 검증 팀                                                          │    │
│  │  • 증거 기반 검증                                                        │    │
│  │  • 반증 시도                                                             │    │
│  └─────────────────────────────────────────────────────────────────────────┘    │
│                                                                                  │
└─────────────────────────────────────────────────────────────────────────────────┘
```

---

## 2. 실행 규칙

### 2.1 트리거 키워드

| 키워드 | 실행 내용 |
|--------|----------|
| **"계단식 분석 시작"** | 전체 프로토콜 실행, 새 세션 폴더 생성 |
| **"계단식 분석 계속"** | 기존 세션의 다음 Phase 실행 |
| **"Phase N 실행"** | 특정 Phase만 실행 |
| **"검증 실행"** | 자동 검증 시스템만 실행 |
| **"품질 스코어"** | 현재 세션의 품질 스코어 계산 |
| **"세션 비교"** | 이전 세션과 현재 세션 비교 |

### 2.2 세션 폴더 생성 규칙

```
실행 경로:
1. 사용자 "계단식 분석 시작" 트리거
2. 현재 시각 확인: date "+%Y%m%d_%H%M%S"
3. 세션 폴더 생성: !AGENT_Analysis/YYYYMMDD_HHMMSS/
4. 상태 파일 생성: 00_META/00_STATE.yaml
5. Phase 0 시작
```

**폴더 구조**:

```
!AGENT_Analysis/
├── 20251211_084719/          # 세션 1
│   ├── 00_META/              # 메타 정보
│   │   ├── 00_STATE.yaml     # 상태 머신 (현재 Phase)
│   │   ├── 01_SESSION_INFO.md # 세션 정보
│   │   └── 02_VALIDATION_LOG.md # 검증 로그
│   ├── 10_숲분석/            # Phase 1-2 결과
│   │   ├── 01_폴더구조.md
│   │   ├── 02_핵심모듈.md
│   │   └── 03_의존성그래프.md
│   ├── 20_나무분석/          # Phase 3 결과
│   │   └── [모듈명]_분석.md
│   ├── 30_잎분석/            # Phase 4 결과
│   │   └── [함수명]_정밀분석.md
│   ├── 40_연결분석/          # Phase 5 결과
│   │   ├── 01_호출그래프.md
│   │   └── 02_DeadCode목록.md
│   ├── 50_부재분석/          # Phase 6 결과
│   │   └── 01_누락목록.md
│   ├── 60_교차검증/          # Phase 7 결과
│   │   └── 01_검증결과.md
│   ├── 70_종합/              # Phase 8 결과
│   │   ├── 01_최종보고서.md
│   │   ├── 02_품질스코어.md
│   │   └── 03_미분석파일.md
│   └── 99_증거/              # 모든 증거 코드
│       └── [파일별]_증거.md
│
├── 20251212_143022/          # 세션 2 (누적)
│   └── ...
```

### 2.3 상태 머신 정의 (YAML 형식)

**파일**: `00_META/00_STATE.yaml`

```yaml
# 계단식 분석 상태 머신
session:
  id: "20251211_084719"
  created: "2025-12-11 08:47:19"
  project: "[프로젝트명]"
  
current_state:
  phase: 0                    # 현재 Phase (0-8)
  status: "in_progress"       # in_progress | completed | failed | paused
  last_updated: "2025-12-11 08:47:19"

phase_history:
  - phase: 0
    status: "completed"
    started: "2025-12-11 08:47:19"
    completed: "2025-12-11 08:50:32"
    output_files:
      - "00_META/01_SESSION_INFO.md"
    validation:
      passed: true
      score: 100

next_action:
  phase: 1
  description: "숲 분석 - 전체 폴더 구조 파악"
  required_input: "00_META/01_SESSION_INFO.md"
  expected_output:
    - "10_숲분석/01_폴더구조.md"

validation_status:
  existence: null              # 존재 검증 결과
  consistency: null            # 일관성 검증 결과
  evidence: null               # 증거 검증 결과
  coverage: null               # 커버리지 검증 결과
  overall_score: null          # 종합 점수

failure_recovery:
  last_failure: null
  recovery_action: null
  retry_count: 0
```

**상태 전이 규칙**:

```
Phase 0 (초기화) ─────완료────→ Phase 1 (고도 탐색)
       │                              │
       └──실패──→ 재시도 또는 중단    ↓
                                Phase 2 (숲 분석)
                                      │
                                      ↓
                                Phase 3 (나무 분석)
                                      │
                                      ↓
                                Phase 4 (잎 분석)
                                      │
                                      ↓
                                Phase 5 (연결 분석)
                                      │
                                      ↓
                                Phase 6 (부재 분석)
                                      │
                                      ↓
                                Phase 7 (교차 검증)
                                      │
                                      ↓
                                Phase 8 (종합 + 품질 스코어)
                                      │
                                      ↓
                                    완료
```

---

## 3. 분석 단계 (8 Phase)

### 3.1 Phase 0: 세션 초기화

```
╔═════════════════════════════════════════════════════════════════════════════════╗
║  Phase 0: 세션 초기화 (Session Initialization)                                   ║
╠═════════════════════════════════════════════════════════════════════════════════╣
║                                                                                  ║
║  ■ 목적: 분석 세션 설정 및 전체 파일 목록 수집                                  ║
║                                                                                  ║
║  ■ 실행 단계:                                                                   ║
║    1. 현재 시각 확인: date "+%Y%m%d_%H%M%S"                                     ║
║    2. 세션 폴더 생성: !AGENT_Analysis/YYYYMMDD_HHMMSS/                          ║
║    3. 상태 파일 생성: 00_META/00_STATE.yaml                                     ║
║    4. 전체 파일 목록 수집: find 또는 list_dir                                   ║
║    5. 파일 분류: 코드/설정/테스트/문서/기타                                     ║
║    6. 프로젝트 유형 감지: package.json/requirements.txt 등                      ║
║    7. 분석 계획 생성: 프로젝트 유형에 맞는 계획                                 ║
║                                                                                  ║
║  ■ 산출물:                                                                      ║
║    - 00_META/00_STATE.yaml (상태 머신)                                          ║
║    - 00_META/01_SESSION_INFO.md (세션 정보)                                     ║
║    - 00_META/03_FILE_LIST.md (전체 파일 목록)                                   ║
║    - 00_META/04_ANALYSIS_PLAN.md (분석 계획)                                    ║
║                                                                                  ║
║  ■ 완료 조건:                                                                   ║
║    □ 상태 파일 생성됨                                                           ║
║    □ 전체 파일 목록 수집됨                                                      ║
║    □ 프로젝트 유형 감지됨                                                       ║
║    □ 분석 계획 생성됨                                                           ║
║                                                                                  ║
║  ■ 상태 업데이트:                                                               ║
║    current_state.phase: 0 → 1                                                   ║
║    next_action.phase: 1                                                          ║
║                                                                                  ║
╚═════════════════════════════════════════════════════════════════════════════════╝
```

### 3.2 Phase 1: 고도 탐색 (High-Altitude Survey)

```
╔═════════════════════════════════════════════════════════════════════════════════╗
║  Phase 1: 고도 탐색 (High-Altitude Survey) - 숲 감시자                          ║
╠═════════════════════════════════════════════════════════════════════════════════╣
║                                                                                  ║
║  ■ 목적: 프로젝트 전체 구조 파악 (가장 높은 줌 레벨)                            ║
║                                                                                  ║
║  ■ 필수 선행 조건:                                                              ║
║    □ Phase 0 완료 확인                                                          ║
║    □ 00_META/01_SESSION_INFO.md 읽기                                            ║
║    □ 00_META/03_FILE_LIST.md 읽기                                               ║
║                                                                                  ║
║  ■ 실행 단계:                                                                   ║
║    1. 루트 디렉토리 list_dir 실행                                               ║
║    2. 주요 폴더 식별 (00_code, engine, apps 등)                                 ║
║    3. 진입점 파일 식별 (main.py, index.ts 등)                                   ║
║    4. 설정 파일 식별 (package.json, requirements.txt 등)                        ║
║    5. 핵심 모듈 후보 식별                                                        ║
║    6. 아키텍처 스케치 작성                                                       ║
║                                                                                  ║
║  ■ 산출물:                                                                      ║
║    - 10_숲분석/01_폴더구조.md                                                   ║
║    - 10_숲분석/02_진입점목록.md                                                 ║
║    - 10_숲분석/03_핵심모듈후보.md                                               ║
║                                                                                  ║
║  ■ 완료 조건:                                                                   ║
║    □ 폴더 구조 문서화됨                                                         ║
║    □ 진입점 식별됨                                                              ║
║    □ 핵심 모듈 후보 식별됨                                                      ║
║                                                                                  ║
║  ■ 상태 업데이트:                                                               ║
║    current_state.phase: 1 → 2                                                   ║
║    phase_history 추가                                                            ║
║                                                                                  ║
╚═════════════════════════════════════════════════════════════════════════════════╝
```

### 3.3 Phase 2: 숲 분석 (Forest Analysis)

```
╔═════════════════════════════════════════════════════════════════════════════════╗
║  Phase 2: 숲 분석 (Forest Analysis) - 숲 감시자 + 연결 추적자                   ║
╠═════════════════════════════════════════════════════════════════════════════════╣
║                                                                                  ║
║  ■ 목적: 모듈 간 의존성 분석, 전체 흐름 파악                                    ║
║                                                                                  ║
║  ■ 필수 선행 조건:                                                              ║
║    □ Phase 1 완료 확인 (00_STATE.yaml 읽기)                                     ║
║    □ 10_숲분석/01_폴더구조.md 읽기                                              ║
║    □ 10_숲분석/03_핵심모듈후보.md 읽기                                          ║
║                                                                                  ║
║  ■ 실행 단계:                                                                   ║
║    1. 진입점에서 시작하는 import 체인 추적                                       ║
║    2. 모듈 간 의존성 그래프 작성                                                 ║
║    3. 순환 의존성 탐지                                                           ║
║    4. 핵심 경로(Critical Path) 식별                                              ║
║    5. 데이터 흐름 대략 파악                                                      ║
║                                                                                  ║
║  ■ 산출물:                                                                      ║
║    - 10_숲분석/04_의존성그래프.md                                               ║
║    - 10_숲분석/05_핵심경로.md                                                   ║
║    - 10_숲분석/06_순환의존성.md                                                 ║
║                                                                                  ║
║  ■ 완료 조건:                                                                   ║
║    □ 의존성 그래프 작성됨                                                       ║
║    □ 핵심 경로 식별됨                                                           ║
║    □ 순환 의존성 탐지 완료                                                      ║
║                                                                                  ║
╚═════════════════════════════════════════════════════════════════════════════════╝
```

### 3.4 Phase 3: 나무 분석 (Tree Analysis)

```
╔═════════════════════════════════════════════════════════════════════════════════╗
║  Phase 3: 나무 분석 (Tree Analysis) - 나무 분석가                               ║
╠═════════════════════════════════════════════════════════════════════════════════╣
║                                                                                  ║
║  ■ 목적: 핵심 모듈 전체 읽기, 클래스/함수 구조 파악                             ║
║                                                                                  ║
║  ■ 필수 선행 조건:                                                              ║
║    □ Phase 2 완료 확인 (00_STATE.yaml 읽기)                                     ║
║    □ 10_숲분석/05_핵심경로.md 읽기                                              ║
║                                                                                  ║
║  ■ 실행 단계:                                                                   ║
║    1. 핵심 경로의 모듈 목록 추출                                                 ║
║    2. 각 모듈 전체 읽기 (read_file)                                             ║
║    3. 클래스/함수 목록 추출                                                      ║
║    4. 공개 인터페이스 식별                                                       ║
║    5. 주요 로직 이해 및 요약                                                     ║
║    6. 각 모듈별 분석 파일 생성                                                   ║
║                                                                                  ║
║  ■ 산출물:                                                                      ║
║    - 20_나무분석/[모듈명]_분석.md (모듈별)                                      ║
║    - 20_나무분석/00_모듈요약.md (전체 요약)                                     ║
║                                                                                  ║
║  ■ 완료 조건:                                                                   ║
║    □ 모든 핵심 모듈 분석됨                                                      ║
║    □ 각 모듈별 분석 파일 생성됨                                                 ║
║    □ 클래스/함수 목록 완성됨                                                    ║
║                                                                                  ║
║  ■ 맥락 관리:                                                                   ║
║    - 모듈 하나 분석 후 파일 저장                                                 ║
║    - 다음 모듈 분석 전 이전 파일 참조 가능                                       ║
║    - 맥락 창 초과 시 이전 파일에서 복원                                          ║
║                                                                                  ║
╚═════════════════════════════════════════════════════════════════════════════════╝
```

### 3.5 Phase 4: 잎 분석 (Leaf Analysis)

```
╔═════════════════════════════════════════════════════════════════════════════════╗
║  Phase 4: 잎 분석 (Leaf Analysis) - 잎 검사관                                   ║
╠═════════════════════════════════════════════════════════════════════════════════╣
║                                                                                  ║
║  ■ 목적: 특정 함수 정밀 분석, 버그/취약점 탐지                                  ║
║                                                                                  ║
║  ■ 필수 선행 조건:                                                              ║
║    □ Phase 3 완료 확인 (00_STATE.yaml 읽기)                                     ║
║    □ 20_나무분석/00_모듈요약.md 읽기                                            ║
║    □ 분석 대상 함수 목록 추출                                                   ║
║                                                                                  ║
║  ■ 실행 단계:                                                                   ║
║    1. 핵심 함수 목록 추출 (나무 분석 결과에서)                                  ║
║    2. 각 함수 정밀 분석:                                                        ║
║       - 모든 조건문 경로 추적                                                    ║
║       - 엣지 케이스 처리 확인                                                    ║
║       - 하드코딩 값 탐지                                                         ║
║       - 에러 처리 확인                                                           ║
║    3. 코드 품질 이슈 기록                                                        ║
║    4. 버그 후보 목록 작성                                                        ║
║                                                                                  ║
║  ■ 산출물:                                                                      ║
║    - 30_잎분석/[함수명]_정밀분석.md (함수별)                                    ║
║    - 30_잎분석/00_버그후보.md                                                   ║
║    - 30_잎분석/01_하드코딩목록.md                                               ║
║                                                                                  ║
║  ■ 완료 조건:                                                                   ║
║    □ 핵심 함수 정밀 분석됨                                                      ║
║    □ 버그 후보 목록 작성됨                                                      ║
║    □ 하드코딩 목록 작성됨                                                       ║
║                                                                                  ║
╚═════════════════════════════════════════════════════════════════════════════════╝
```

### 3.6 Phase 5: 연결 분석 (Connection Analysis)

```
╔═════════════════════════════════════════════════════════════════════════════════╗
║  Phase 5: 연결 분석 (Connection Analysis) - 연결 추적자                         ║
╠═════════════════════════════════════════════════════════════════════════════════╣
║                                                                                  ║
║  ■ 목적: 함수 호출 관계 추적, Dead Code 탐지                                    ║
║                                                                                  ║
║  ■ 필수 선행 조건:                                                              ║
║    □ Phase 4 완료 확인 (00_STATE.yaml 읽기)                                     ║
║    □ 20_나무분석/00_모듈요약.md 읽기 (함수 목록)                                ║
║                                                                                  ║
║  ■ 실행 단계:                                                                   ║
║    1. 각 함수/클래스에 대해 grep 실행                                           ║
║       - grep -n "함수명\(" 전체 코드                                            ║
║    2. 호출자 수 집계                                                             ║
║    3. Dead Code 식별:                                                            ║
║       - 정의되었지만 호출 안 되는 함수                                           ║
║       - import 되었지만 사용 안 되는 모듈                                        ║
║    4. 호출 그래프 작성                                                           ║
║    5. 실제 사용 여부 확인                                                        ║
║                                                                                  ║
║  ■ 산출물:                                                                      ║
║    - 40_연결분석/01_호출그래프.md                                               ║
║    - 40_연결분석/02_DeadCode목록.md                                             ║
║    - 40_연결분석/03_미사용Import.md                                             ║
║                                                                                  ║
║  ■ 완료 조건:                                                                   ║
║    □ 호출 그래프 작성됨                                                         ║
║    □ Dead Code 목록 작성됨                                                      ║
║    □ 미사용 import 목록 작성됨                                                  ║
║                                                                                  ║
╚═════════════════════════════════════════════════════════════════════════════════╝
```

### 3.7 Phase 6: 부재 분석 (Absence Analysis)

```
╔═════════════════════════════════════════════════════════════════════════════════╗
║  Phase 6: 부재 분석 (Absence Analysis) - 부재 탐지자                            ║
╠═════════════════════════════════════════════════════════════════════════════════╣
║                                                                                  ║
║  ■ 목적: 있어야 하는데 없는 것 탐지                                             ║
║                                                                                  ║
║  ■ 필수 선행 조건:                                                              ║
║    □ Phase 5 완료 확인 (00_STATE.yaml 읽기)                                     ║
║    □ 30_잎분석/00_버그후보.md 읽기                                              ║
║    □ 40_연결분석/02_DeadCode목록.md 읽기                                        ║
║                                                                                  ║
║  ■ 실행 단계:                                                                   ║
║    1. 에러 처리 누락 탐지:                                                       ║
║       - try-catch 없는 위험 연산                                                 ║
║       - 에러 상태 무시                                                           ║
║    2. 검증 누락 탐지:                                                            ║
║       - 입력 검증 없음                                                           ║
║       - 타입/범위 검증 없음                                                      ║
║    3. 연결 누락 탐지:                                                            ║
║       - 정의되었지만 연결 안 됨                                                  ║
║       - 설계서에는 있지만 구현 안 됨                                             ║
║    4. 문서-코드 불일치 탐지                                                      ║
║                                                                                  ║
║  ■ 산출물:                                                                      ║
║    - 50_부재분석/01_에러처리누락.md                                             ║
║    - 50_부재분석/02_검증누락.md                                                 ║
║    - 50_부재분석/03_연결누락.md                                                 ║
║    - 50_부재분석/04_문서불일치.md                                               ║
║                                                                                  ║
║  ■ 완료 조건:                                                                   ║
║    □ 누락 목록 작성됨                                                           ║
║    □ 각 누락 항목에 위험도 평가됨                                               ║
║                                                                                  ║
╚═════════════════════════════════════════════════════════════════════════════════╝
```

### 3.8 Phase 7: 교차 검증 (Cross Validation)

```
╔═════════════════════════════════════════════════════════════════════════════════╗
║  Phase 7: 교차 검증 (Cross Validation) - 검증 특공대 6개 팀                     ║
╠═════════════════════════════════════════════════════════════════════════════════╣
║                                                                                  ║
║  ■ 목적: 이전 모든 Phase 결과를 검증 특공대로 교차 검증                         ║
║                                                                                  ║
║  ■ 필수 선행 조건:                                                              ║
║    □ Phase 0-6 완료 확인 (00_STATE.yaml 읽기)                                   ║
║    □ 모든 Phase의 산출물 파일 읽기                                              ║
║                                                                                  ║
║  ■ 검증 팀별 실행:                                                              ║
║                                                                                  ║
║  🔬 Forensic Team (VETO 권한):                                                  ║
║    - 모든 결론의 증거 위치 확인                                                  ║
║    - 실제 코드 인용 확인 (read_file)                                            ║
║    - 일치/불일치 판정                                                            ║
║                                                                                  ║
║  ⚔️ Counter-Analysis Team (VETO 권한):                                          ║
║    - 각 결론의 반증 조건 정의                                                    ║
║    - 반증 증거 탐색 (grep)                                                       ║
║    - 반증 성공/실패 판정                                                         ║
║                                                                                  ║
║  🤔 Skeptic Team (VETO 권한):                                                   ║
║    - 검증 과정 검토                                                              ║
║    - 확인 편향 탐지                                                              ║
║    - 신뢰도 등급 부여                                                            ║
║                                                                                  ║
║  🔗 Cross-Reference Team:                                                       ║
║    - Phase 간 결과 비교                                                          ║
║    - 불일치 식별                                                                 ║
║                                                                                  ║
║  🏃 Execution Team:                                                              ║
║    - 실행 경로 분석                                                              ║
║    - 실제 영향 평가                                                              ║
║                                                                                  ║
║  🌐 Meta Team:                                                                   ║
║    - 전체 통합 분석                                                              ║
║    - 최종 우선순위 도출                                                          ║
║                                                                                  ║
║  ■ 산출물:                                                                      ║
║    - 60_교차검증/01_Forensic_검증.md                                            ║
║    - 60_교차검증/02_Counter_반증.md                                             ║
║    - 60_교차검증/03_Skeptic_신뢰도.md                                           ║
║    - 60_교차검증/04_CrossRef_비교.md                                            ║
║    - 60_교차검증/05_Execution_경로.md                                           ║
║    - 60_교차검증/06_Meta_통합.md                                                ║
║    - 60_교차검증/07_VETO_목록.md (있는 경우)                                    ║
║                                                                                  ║
║  ■ VETO 조건:                                                                   ║
║    - Forensic: 증거와 실제 불일치                                                ║
║    - Counter: 반증 성공 (주장이 틀림)                                            ║
║    - Skeptic: 검증 과정 불충분/편향                                              ║
║                                                                                  ║
╚═════════════════════════════════════════════════════════════════════════════════╝
```

### 3.9 Phase 8: 종합 및 품질 스코어 (Synthesis)

```
╔═════════════════════════════════════════════════════════════════════════════════╗
║  Phase 8: 종합 및 품질 스코어 (Synthesis & Quality Score)                       ║
╠═════════════════════════════════════════════════════════════════════════════════╣
║                                                                                  ║
║  ■ 목적: 모든 분석 결과 종합, 품질 스코어 계산, 최종 보고서 생성                ║
║                                                                                  ║
║  ■ 필수 선행 조건:                                                              ║
║    □ Phase 7 완료 확인 (00_STATE.yaml 읽기)                                     ║
║    □ 60_교차검증/ 폴더의 모든 파일 읽기                                         ║
║    □ VETO 목록 확인                                                              ║
║                                                                                  ║
║  ■ 실행 단계:                                                                   ║
║    1. 모든 Phase 결과 종합                                                       ║
║    2. 품질 스코어 계산 (4개 지표)                                               ║
║    3. 커버리지 보고서 작성                                                       ║
║    4. 미분석 파일 목록 작성 (필수!)                                             ║
║    5. 최종 보고서 작성                                                           ║
║    6. 권장 조치 사항 정리                                                        ║
║                                                                                  ║
║  ■ 산출물:                                                                      ║
║    - 70_종합/01_최종보고서.md                                                   ║
║    - 70_종합/02_품질스코어.md                                                   ║
║    - 70_종합/03_미분석파일.md (MANDATORY)                                       ║
║    - 70_종합/04_커버리지보고서.md                                               ║
║    - 70_종합/05_권장조치.md                                                     ║
║                                                                                  ║
║  ■ 품질 스코어 계산:                                                            ║
║    Quality Score = (Coverage×25 + Evidence×25 + Consistency×25 + Depth×25) / 100║
║                                                                                  ║
║  ■ 완료 조건:                                                                   ║
║    □ 품질 스코어 ≥ 70점                                                         ║
║    □ 미분석 파일 목록 작성됨                                                    ║
║    □ 최종 보고서 작성됨                                                         ║
║    □ 상태 머신 "completed"로 업데이트                                           ║
║                                                                                  ║
╚═════════════════════════════════════════════════════════════════════════════════╝
```

---

## 4. 파일 구조 및 템플릿

### 4.1 상태 파일 템플릿 (00_STATE.yaml)

```yaml
# 계단식 분석 상태 머신
# 이 파일을 읽으면 AI는 현재 상태와 다음 할 일을 안다

session:
  id: "YYYYMMDD_HHMMSS"
  created: "YYYY-MM-DD HH:MM:SS"
  project: "[프로젝트명]"
  project_type: "[python/node/rust/etc]"
  
current_state:
  phase: 0                    # 0-8
  status: "in_progress"       # in_progress | completed | failed | paused
  last_updated: "YYYY-MM-DD HH:MM:SS"

phase_history:
  - phase: 0
    status: "completed"
    started: "YYYY-MM-DD HH:MM:SS"
    completed: "YYYY-MM-DD HH:MM:SS"
    output_files:
      - "파일 경로"
    validation:
      passed: true
      score: 100
      issues: []

next_action:
  phase: 1
  description: "다음 단계 설명"
  required_input:
    - "읽어야 할 이전 파일"
  expected_output:
    - "생성할 파일"

validation_status:
  existence:
    passed: null
    checked_items: 0
    failed_items: []
  consistency:
    passed: null
    checked_items: 0
    inconsistencies: []
  evidence:
    passed: null
    total_claims: 0
    evidenced_claims: 0
    missing_evidence: []
  coverage:
    total_files: 0
    analyzed_files: 0
    unanalyzed_files: []
    percentage: 0
  overall_score: null

failure_recovery:
  last_failure: null
  failure_type: null          # file_read | validation | context_overflow | analysis_block
  recovery_action: null
  retry_count: 0
  max_retries: 3
```

### 4.2 세션 정보 템플릿 (01_SESSION_INFO.md)

```markdown
# 계단식 분석 세션 정보

**세션 ID**: YYYYMMDD_HHMMSS
**생성일**: YYYY-MM-DD HH:MM:SS
**프로젝트**: [프로젝트명]
**프로젝트 유형**: [python/node/rust/etc]

---

## 분석 범위

### 대상 폴더
- [폴더 목록]

### 제외 폴더
- node_modules/
- venv/
- __pycache__/
- .git/

### 파일 통계
| 유형 | 수량 |
|------|------|
| 전체 파일 | N개 |
| 코드 파일 | N개 |
| 설정 파일 | N개 |
| 테스트 파일 | N개 |
| 문서 파일 | N개 |

---

## 분석 계획

### 프로젝트 유형 감지
- 감지 방법: [package.json / requirements.txt / Cargo.toml 등]
- 주요 언어: [Python / TypeScript / Rust 등]
- 프레임워크: [FastAPI / React / etc]

### 핵심 분석 영역
1. [영역 1]
2. [영역 2]
3. [영역 3]

---

## 이전 세션 참조 (있는 경우)

- 이전 세션: [세션 ID]
- 변경 사항: [요약]
```

### 4.3 Phase별 분석 파일 템플릿

```markdown
# Phase N: [Phase 이름] 분석 결과

**세션**: YYYYMMDD_HHMMSS
**Phase**: N
**시작**: YYYY-MM-DD HH:MM:SS
**완료**: YYYY-MM-DD HH:MM:SS

---

## 선행 조건 확인

□ 이전 Phase 완료 확인: [00_STATE.yaml 확인됨]
□ 필수 입력 파일 읽기:
  - [파일1] ✅
  - [파일2] ✅

---

## 분석 결과

### [섹션 1]

[분석 내용]

**증거**:
- 파일: [경로:라인]
- 코드:
```[언어]
[실제 코드 인용]
```

### [섹션 2]

[분석 내용]

---

## 발견 사항 요약

| 항목 | 상태 | 증거 위치 |
|------|------|----------|
| [항목1] | [상태] | [파일:라인] |

---

## 다음 Phase를 위한 입력

다음 Phase에서 읽어야 할 핵심 정보:
1. [정보1]
2. [정보2]

---

## 검증 상태

- 존재 검증: [통과/실패]
- 증거 인용: [N개 / M개 중]
```

---

## 5. 자동 검증 규칙

### 5.1 검증 유형

```
╔═════════════════════════════════════════════════════════════════════════════════╗
║                           자동 검증 시스템 (4종류)                               ║
╠═════════════════════════════════════════════════════════════════════════════════╣
║                                                                                  ║
║  1. 존재 검증 (Existence Validation)                                            ║
║  ┌─────────────────────────────────────────────────────────────────────────┐    ║
║  │  목적: 참조된 파일/코드가 실제로 존재하는가?                            │    ║
║  │                                                                         │    ║
║  │  방법:                                                                  │    ║
║  │  - 분석 파일에서 파일 경로 추출                                         │    ║
║  │  - 각 경로에 대해 read_file 또는 ls 실행                               │    ║
║  │  - 존재하지 않으면 FAIL                                                 │    ║
║  │                                                                         │    ║
║  │  명령어 예시:                                                           │    ║
║  │  ```bash                                                                │    ║
║  │  # 파일 존재 확인                                                       │    ║
║  │  ls -la [파일경로] 2>/dev/null && echo "EXISTS" || echo "NOT_FOUND"    │    ║
║  │  ```                                                                    │    ║
║  └─────────────────────────────────────────────────────────────────────────┘    ║
║                                                                                  ║
║  2. 일관성 검증 (Consistency Validation)                                        ║
║  ┌─────────────────────────────────────────────────────────────────────────┐    ║
║  │  목적: 파일 간 내용이 일치하는가?                                       │    ║
║  │                                                                         │    ║
║  │  방법:                                                                  │    ║
║  │  - Phase 간 동일 항목 비교                                              │    ║
║  │  - 숲 분석의 모듈 목록 vs 나무 분석의 모듈 목록                        │    ║
║  │  - 나무 분석의 함수 목록 vs 잎 분석의 함수 목록                        │    ║
║  │  - 불일치 시 WARN 또는 FAIL                                            │    ║
║  │                                                                         │    ║
║  │  검사 항목:                                                             │    ║
║  │  - 모듈 수 일치                                                         │    ║
║  │  - 함수 수 일치                                                         │    ║
║  │  - 파일 경로 일치                                                       │    ║
║  └─────────────────────────────────────────────────────────────────────────┘    ║
║                                                                                  ║
║  3. 증거 검증 (Evidence Validation)                                             ║
║  ┌─────────────────────────────────────────────────────────────────────────┐    ║
║  │  목적: 모든 결론에 증거 코드가 있는가?                                  │    ║
║  │                                                                         │    ║
║  │  방법:                                                                  │    ║
║  │  - 분석 파일에서 "결론" 또는 "발견" 섹션 추출                          │    ║
║  │  - 각 결론에 "증거" 또는 "파일:라인" 패턴 있는지 확인                  │    ║
║  │  - 증거 위치에서 실제 코드 확인                                         │    ║
║  │  - 증거 없으면 FAIL                                                     │    ║
║  │                                                                         │    ║
║  │  명령어 예시:                                                           │    ║
║  │  ```bash                                                                │    ║
║  │  # 결론 개수 확인                                                       │    ║
║  │  grep -c "결론:" [분석파일]                                             │    ║
║  │                                                                         │    ║
║  │  # 증거 개수 확인                                                       │    ║
║  │  grep -c "증거:" [분석파일]                                             │    ║
║  │                                                                         │    ║
║  │  # 두 숫자가 일치해야 함                                                │    ║
║  │  ```                                                                    │    ║
║  └─────────────────────────────────────────────────────────────────────────┘    ║
║                                                                                  ║
║  4. 커버리지 검증 (Coverage Validation)                                         ║
║  ┌─────────────────────────────────────────────────────────────────────────┐    ║
║  │  목적: 분석 커버리지가 충분한가?                                        │    ║
║  │                                                                         │    ║
║  │  방법:                                                                  │    ║
║  │  - 전체 파일 목록 (00_META/03_FILE_LIST.md)                            │    ║
║  │  - 분석된 파일 목록 (각 Phase의 산출물에서 추출)                       │    ║
║  │  - 커버리지 = 분석된 파일 / 전체 파일 × 100                            │    ║
║  │  - 미분석 파일 목록 생성 (필수!)                                       │    ║
║  │                                                                         │    ║
║  │  최소 기준:                                                             │    ║
║  │  - 코드 파일 커버리지 ≥ 60%                                            │    ║
║  │  - 핵심 모듈 커버리지 = 100%                                           │    ║
║  │  - 미분석 파일 목록 필수 작성                                          │    ║
║  └─────────────────────────────────────────────────────────────────────────┘    ║
║                                                                                  ║
╚═════════════════════════════════════════════════════════════════════════════════╝
```

### 5.2 검증 실행 시점

| 시점 | 검증 유형 | 필수 여부 |
|------|----------|----------|
| Phase 완료 시 | 존재 + 증거 | 필수 |
| Phase 7 시작 시 | 일관성 | 필수 |
| Phase 8 시작 시 | 커버리지 | 필수 |
| 세션 완료 시 | 전체 4종류 | 필수 |

### 5.3 검증 로그 템플릿 (02_VALIDATION_LOG.md)

```markdown
# 검증 로그

**세션**: YYYYMMDD_HHMMSS
**마지막 검증**: YYYY-MM-DD HH:MM:SS

---

## 존재 검증 (Existence)

| 항목 | 경로 | 상태 | 검증 시각 |
|------|------|------|----------|
| [항목1] | [경로] | ✅ EXISTS | HH:MM:SS |
| [항목2] | [경로] | ❌ NOT_FOUND | HH:MM:SS |

**결과**: PASS / FAIL
**실패 항목**: N개

---

## 일관성 검증 (Consistency)

| Phase A | Phase B | 항목 | 일치 여부 |
|---------|---------|------|----------|
| Phase 1 | Phase 3 | 모듈 수 | ✅ 일치 (15개) |
| Phase 3 | Phase 4 | 함수 수 | ⚠️ 불일치 (50 vs 48) |

**결과**: PASS / WARN / FAIL
**불일치 항목**: N개

---

## 증거 검증 (Evidence)

| 파일 | 결론 수 | 증거 수 | 비율 |
|------|---------|---------|------|
| [파일1] | 10 | 10 | 100% |
| [파일2] | 5 | 3 | 60% ⚠️ |

**전체 결론**: N개
**증거 있는 결론**: M개
**증거율**: M/N × 100 = X%

**결과**: PASS (≥90%) / WARN (≥70%) / FAIL (<70%)

---

## 커버리지 검증 (Coverage)

| 유형 | 전체 | 분석됨 | 미분석 | 비율 |
|------|------|--------|--------|------|
| 코드 파일 | 100 | 80 | 20 | 80% |
| 핵심 모듈 | 15 | 15 | 0 | 100% |
| 테스트 | 30 | 10 | 20 | 33% |

**미분석 파일 목록**: 70_종합/03_미분석파일.md 참조

**결과**: PASS / WARN / FAIL

---

## 종합 결과

| 검증 유형 | 결과 | 점수 |
|----------|------|------|
| 존재 | PASS | 100 |
| 일관성 | WARN | 80 |
| 증거 | PASS | 95 |
| 커버리지 | PASS | 85 |

**종합 점수**: (100 + 80 + 95 + 85) / 4 = 90점
```

---

## 6. 품질 스코어

### 6.1 스코어 계산

```
╔═════════════════════════════════════════════════════════════════════════════════╗
║                              품질 스코어 계산식                                  ║
╠═════════════════════════════════════════════════════════════════════════════════╣
║                                                                                  ║
║  Quality Score = (Coverage×25 + Evidence×25 + Consistency×25 + Depth×25) / 100  ║
║                                                                                  ║
║  ┌─────────────────────────────────────────────────────────────────────────┐    ║
║  │  1. Coverage (커버리지) - 25점                                          │    ║
║  │     = (분석된 코드 파일 / 전체 코드 파일) × 100                        │    ║
║  │     - 100% = 25점                                                       │    ║
║  │     - 80% = 20점                                                        │    ║
║  │     - 60% = 15점                                                        │    ║
║  │     - 60% 미만 = 0점 (FAIL)                                            │    ║
║  └─────────────────────────────────────────────────────────────────────────┘    ║
║                                                                                  ║
║  ┌─────────────────────────────────────────────────────────────────────────┐    ║
║  │  2. Evidence (증거율) - 25점                                            │    ║
║  │     = (증거 있는 결론 / 전체 결론) × 100                               │    ║
║  │     - 100% = 25점                                                       │    ║
║  │     - 90% = 22.5점                                                      │    ║
║  │     - 70% 미만 = 0점 (FAIL)                                            │    ║
║  └─────────────────────────────────────────────────────────────────────────┘    ║
║                                                                                  ║
║  ┌─────────────────────────────────────────────────────────────────────────┐    ║
║  │  3. Consistency (일관성) - 25점                                         │    ║
║  │     = (일치 항목 / 전체 비교 항목) × 100                               │    ║
║  │     - 100% = 25점                                                       │    ║
║  │     - 불일치 1개당 -2점                                                 │    ║
║  └─────────────────────────────────────────────────────────────────────────┘    ║
║                                                                                  ║
║  ┌─────────────────────────────────────────────────────────────────────────┐    ║
║  │  4. Depth (분석 깊이) - 25점                                            │    ║
║  │     = 완료된 Phase 수 / 8 × 25                                         │    ║
║  │     - Phase 8 완료 = 25점                                               │    ║
║  │     - Phase 4까지만 = 12.5점                                            │    ║
║  └─────────────────────────────────────────────────────────────────────────┘    ║
║                                                                                  ║
╚═════════════════════════════════════════════════════════════════════════════════╝
```

### 6.2 스코어 임계값

| 등급 | 점수 범위 | 의미 | 조치 |
|------|----------|------|------|
| **A** | 90-100 | 우수 | 분석 완료 |
| **B** | 80-89 | 양호 | 권장 완료, 추가 분석 선택 |
| **C** | 70-79 | 최소 기준 | 미분석 영역 확인 필요 |
| **F** | 70 미만 | 불충분 | 추가 분석 필수 |

### 6.3 품질 스코어 보고서 템플릿

```markdown
# 품질 스코어 보고서

**세션**: YYYYMMDD_HHMMSS
**계산 시각**: YYYY-MM-DD HH:MM:SS

---

## 종합 점수

```
╔═══════════════════════════════════════╗
║                                       ║
║       Quality Score: 85 / 100         ║
║                                       ║
║           등급: B (양호)              ║
║                                       ║
╚═══════════════════════════════════════╝
```

---

## 세부 점수

| 지표 | 값 | 점수 (25점 만점) |
|------|-----|-----------------|
| Coverage | 80% | 20.0 |
| Evidence | 95% | 23.75 |
| Consistency | 90% | 22.5 |
| Depth | 8/8 Phase | 25.0 |
| **합계** | | **91.25** |

---

## 개선 권장 사항

### 커버리지 개선
- 미분석 파일: 20개
- 권장: 핵심 모듈 우선 분석

### 증거 개선
- 증거 없는 결론: 3개
- 위치: [파일 목록]

---

## 비교 (이전 세션 대비)

| 지표 | 이전 | 현재 | 변화 |
|------|------|------|------|
| Coverage | 70% | 80% | +10% ⬆️ |
| Evidence | 90% | 95% | +5% ⬆️ |
| Score | 78 | 85 | +7 ⬆️ |
```

---

## 7. 실패 복구

### 7.1 실패 유형

```
╔═════════════════════════════════════════════════════════════════════════════════╗
║                              실패 유형 및 대응                                   ║
╠═════════════════════════════════════════════════════════════════════════════════╣
║                                                                                  ║
║  1. 파일 읽기 실패 (file_read)                                                  ║
║  ┌─────────────────────────────────────────────────────────────────────────┐    ║
║  │  원인: 파일 없음, 권한 없음, 경로 오류                                  │    ║
║  │  대응:                                                                  │    ║
║  │    1. 재시도 (최대 3회)                                                 │    ║
║  │    2. 대체 경로 탐색                                                    │    ║
║  │    3. 해당 파일 건너뛰기 + 미분석 목록에 추가                          │    ║
║  │    4. 상태 파일에 failure_recovery 업데이트                            │    ║
║  └─────────────────────────────────────────────────────────────────────────┘    ║
║                                                                                  ║
║  2. 검증 실패 (validation)                                                      ║
║  ┌─────────────────────────────────────────────────────────────────────────┐    ║
║  │  원인: 증거 부족, 일관성 불일치, 커버리지 미달                         │    ║
║  │  대응:                                                                  │    ║
║  │    1. 실패 원인 분석                                                    │    ║
║  │    2. 해당 Phase 재실행 또는 보완                                      │    ║
║  │    3. 보완 후 재검증                                                    │    ║
║  │    4. 3회 실패 시 사용자에게 알림                                      │    ║
║  └─────────────────────────────────────────────────────────────────────────┘    ║
║                                                                                  ║
║  3. 맥락 창 초과 (context_overflow)                                             ║
║  ┌─────────────────────────────────────────────────────────────────────────┐    ║
║  │  원인: 분석 대상이 너무 큼                                              │    ║
║  │  대응:                                                                  │    ║
║  │    1. 현재까지 분석 결과 파일로 저장                                   │    ║
║  │    2. 상태 파일에 "paused" + 재개 위치 기록                            │    ║
║  │    3. "계단식 분석 계속" 명령으로 재개                                 │    ║
║  │    4. 이전 파일 읽기로 맥락 복원                                       │    ║
║  └─────────────────────────────────────────────────────────────────────────┘    ║
║                                                                                  ║
║  4. 분석 막힘 (analysis_block)                                                  ║
║  ┌─────────────────────────────────────────────────────────────────────────┐    ║
║  │  원인: 복잡한 코드, 이해 불가, 정보 부족                               │    ║
║  │  대응:                                                                  │    ║
║  │    1. 막힌 부분 표시 + 이유 기록                                       │    ║
║  │    2. 해당 부분 건너뛰기 + 후속 분석 목록에 추가                       │    ║
║  │    3. 다른 부분 먼저 분석 후 돌아오기                                  │    ║
║  │    4. 사용자에게 추가 정보 요청                                        │    ║
║  └─────────────────────────────────────────────────────────────────────────┘    ║
║                                                                                  ║
╚═════════════════════════════════════════════════════════════════════════════════╝
```

### 7.2 복구 프로세스

```
실패 발생 → 실패 유형 판별 → 상태 파일 업데이트
              │
              ├── file_read → 재시도 (3회) → 건너뛰기 + 미분석 목록
              │
              ├── validation → 원인 분석 → 보완 → 재검증
              │
              ├── context_overflow → 저장 → paused → 재개 가능
              │
              └── analysis_block → 표시 → 건너뛰기 → 나중에 재시도
```

---

## 8. 프로젝트 적응

### 8.1 프로젝트 유형 자동 감지

| 파일 | 프로젝트 유형 | 특화 분석 |
|------|--------------|----------|
| `package.json` | Node.js | npm 의존성, React/Vue 컴포넌트 |
| `requirements.txt` / `pyproject.toml` | Python | 모듈 구조, FastAPI/Django |
| `Cargo.toml` | Rust | crate 구조, unsafe 블록 |
| `go.mod` | Go | 패키지 구조, goroutine |
| `pom.xml` / `build.gradle` | Java | 클래스 계층, Spring |

### 8.2 유형별 분석 계획 조정

```yaml
# Python 프로젝트 분석 계획
python_project:
  phase_adjustments:
    phase_3:
      focus:
        - "클래스 상속 구조"
        - "데코레이터 패턴"
        - "타입 힌트 확인"
    phase_4:
      focus:
        - "예외 처리 패턴"
        - "컨텍스트 매니저"
    phase_5:
      focus:
        - "__init__.py 분석"
        - "순환 import 탐지"
  
  special_checks:
    - "async/await 패턴"
    - "typing 사용"
    - "테스트 커버리지"

# Node.js 프로젝트 분석 계획
nodejs_project:
  phase_adjustments:
    phase_3:
      focus:
        - "export/import 구조"
        - "React 컴포넌트 계층"
        - "훅(Hooks) 사용 패턴"
    phase_4:
      focus:
        - "Promise/async 처리"
        - "에러 바운더리"
    phase_5:
      focus:
        - "node_modules 의존성"
        - "번들 크기 분석"
  
  special_checks:
    - "TypeScript 타입 체크"
    - "ESLint 규칙"
    - "React 최적화"
```

---

## 9. 기존 프레임워크 통합

### 9.1 01_분석 (Adversarial Framework) 통합

```
통합 지점: Phase 7 (교차 검증)

적용 요소:
- VETO 시스템: Forensic, Counter, Skeptic 팀에 VETO 권한
- 가중 투표: 각 팀 결과에 가중치 적용
- 소수 의견 보호: 다수와 다른 의견 별도 기록
```

### 9.2 02_검증 (Verification Strike Force) 통합

```
통합 지점: Phase 7 (교차 검증)

적용 요소:
- 6개 팀 구조:
  - Forensic Team (VETO): 증거 확인
  - Counter-Analysis Team (VETO): 반증 시도
  - Skeptic Team (VETO): 검증 과정 검증
  - Cross-Reference Team: 교차 비교
  - Execution Team: 실행 분석
  - Meta Team: 통합 분석

- 검증 출력 형식 표준화
```

### 9.3 03_현장분석 (Forensic Framework) 통합

```
통합 지점: Phase 1-6 (분석 단계)

적용 요소:
- 8개 분석 팀 역할:
  - 포렌식 감식관 (총괄)
  - 숲 감시자 (Phase 1-2)
  - 나무 분석가 (Phase 3)
  - 잎 검사관 (Phase 4)
  - 연결 추적자 (Phase 5)
  - 부재 탐지자 (Phase 6)
  - 커버리지 추적자 (전체)
  - 결론 검증관 (Phase 7-8)

- 줌 레벨 전환 규칙
- 커버리지 추적 필수
- 미분석 파일 목록 필수
```

---

## 10. 사용 가이드

### 10.1 빠른 시작

```bash
# 1. 이 프로토콜 파일을 프로젝트에 복사
cp 04_계단식분석_incremental-forensic-protocol.md [프로젝트]/_COMMAND_LIBRARY/

# 2. 분석 시작 트리거
"계단식 분석 시작"

# 3. 다음 Phase 실행 (세션 중단 후 재개 시)
"계단식 분석 계속"

# 4. 특정 Phase만 실행
"Phase 3 실행"

# 5. 현재 상태 확인
"계단식 분석 상태"

# 6. 품질 스코어 확인
"품질 스코어"
```

### 10.2 세션 관리

```markdown
## 새 세션 시작
1. "계단식 분석 시작" 입력
2. 자동으로 !AGENT_Analysis/YYYYMMDD_HHMMSS/ 생성
3. Phase 0부터 순차 실행

## 기존 세션 계속
1. "계단식 분석 계속" 입력
2. 최신 세션의 00_STATE.yaml 읽기
3. 마지막 완료된 Phase 다음부터 실행

## 이전 세션 비교
1. "세션 비교" 입력
2. 최근 2개 세션의 결과 비교
3. 변경 사항 분석
```

### 10.3 체크리스트

```markdown
## 분석 시작 전
□ 분석 범위 명확한가?
□ 제외 폴더 설정했는가?
□ 이전 세션 결과 확인했는가?

## 각 Phase 완료 후
□ 상태 파일 업데이트됐는가?
□ 산출물 파일 생성됐는가?
□ 다음 Phase 입력 파일 준비됐는가?

## 분석 완료 후
□ 품질 스코어 ≥ 70점인가?
□ 미분석 파일 목록 작성됐는가?
□ 모든 결론에 증거 있는가?
□ VETO 항목 해결됐는가?
```

---

## 11. 버전 이력

| 버전 | 날짜 | 변경 내용 |
|------|------|----------|
| 1.0 | 2025-12-11 | 초기 버전 - 01, 02, 03 프레임워크 통합 |

---

**이 프로토콜은 AI 에이전트의 장점을 극대화하고 단점을 파일 시스템으로 극복합니다.**

**핵심 원칙:**
- 계단은 하나씩 올라간다
- 파일은 AI의 외부 기억이다
- 검증 없이 완료 없다
- 미분석 없이 보고 없다

